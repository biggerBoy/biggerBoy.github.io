<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决Hexo里NexT主题使用needmoreshare2微信分享图片加载失败的问题]]></title>
    <url>%2Fpage%2Fm30t21.html</url>
    <content type="text"><![CDATA[使用hexo搭建的静态博客，NexT主题下开启分享功能，有好几种分享功能，我用的是needmoreshare2的。具体设置是在主题配置文件里，这样设置的 12345678910111213141516needmoreshare2: enable: true postbottom: enable: true options: iconStyle: box boxForm: horizontal position: topCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: vertical position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook 设置完之后，在文章下面会有个分享的小按钮，点击按钮会出来如上配置的那些社交网站的图标，别的都能正常跳转处理推特和脸书是外国的进不去外，只有点击微信时加载不出来，就是下面图片这样的 F12下找到对应的img标签，可以看到它的src属性值是一个链接，链接的参数就是你的当前文章的地址（如下图），把这个链接复制出来直接在地址栏访问也是访问不到的。 可以推测这应该是把你的文章通过这个api生成一个二维码图片返回，但是现在这个api调不通了。 既然找到了问题的根源，那就好办了。就是换个生成二维码的api。 于是在网上找免费的生成二维码的api，找到了两个，一个是中国的http://www.liantu.com/pingtai/，在这个网站有api，即`http://qr.liantu.com/api.php?text=要生成二维码的内容`; 另一个是谷歌的api是https://chart.googleapis.com/chart?cht=qr&amp;chs=500x500&amp;chl=要生成二维码的内容 第一种还有好多参数可以设置 第二个是谷歌的需要翻墙，不方便，所以用的第一种。 现在找到了可以用的api，接下来就是去替换了，找到替换的地方。 这个是在next\source\lib\needsharebutton\needsharebutton.js里,如下图: 这个就是不能访问的旧的api，我们就是要替换这个。 替换后是这样子： 我使用了logo 我们试试效果，hexo g，hexo d然后访问自己的文章显然我们成功了。。 需要注意的是，图片的链接不可以是https的，因为api是http的，加载不了。]]></content>
      <categories>
        <category>技术教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo为文章添加版权信息]]></title>
    <url>%2Fpage%2Fm30t15.html</url>
    <content type="text"><![CDATA[在你的博客里加版权信息是很必要的，因为笔者最近发现有很多网站或个人转发笔者的博文，其中还有的标着原创，真是让人恼火，辛辛苦苦的原创文章被别人未征得同意的情况下转载，转就转了，还标着原创！真是够了！ 所以打算在文章中添加版权信息，有的添加版权信息的插件，是在文章末尾添加，并不是文章的内容部分，这样再被一些爬虫自动抓取文章转载的时候，版权信息是抓不到的。所以必须要让版权信息成为文章的一部分。其次，我们也要把文章的链接，即文章在自己网站访问时的链接给加上，还有作者、标题、发布时间等。 以NexT主题为例 首先我们要准备版权信息模板，在next\layout_macro目录下创建my-copyright.swig文件，内容如下： 1234567891011121314151617181920212223242526272829303132333435&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt;&lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt;&lt;!-- JS库 sweetalert 可修改路径 --&gt;&lt;script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"&gt;&lt;/script&gt;&lt;script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"&gt;&lt;/script&gt;&lt;link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"&gt;&lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:mm:ss") &#125;&#125;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:mm:ss") &#125;&#125;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;&lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a转载请保留原文链接及作者。&lt;/p &lt;/div&gt;&lt;scriptvar clipboard = new Clipboard('.fa-clipboard');clipboard.on('success', $(function()&#123; $(".fa-clipboard").click(function()&#123;swal(&#123; title: "", text: '复制成功', html: false, timer: 500, showConfirmButton: false&#125;); &#125;);&#125;)); &lt;/script&gt;&#123;% endif %&#125; 其中，这三个文件是http协议的，如果你的网站是https的是访问不到的 123&lt;script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"&gt;&lt;/script&gt;&lt;script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"&gt;&lt;/script&gt;&lt;link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"&gt; 那么久先在浏览器访问这三个文件，自己保存到本地的NexT主题的资源目录下，再把my-copyright.swig文件里改成你本地的路径就好了。 这都弄好之后，我们就可以在必要的地方引入模板了。在哪呢？ 在next\layout_macro目录下的post.swig里加，具体在哪个位置呢？先打开它，找到这个地方： 123&#123;#####################&#125;&#123;### END POST BODY ###&#125;&#123;#####################&#125; 在其后面添加如下代码： 12345&lt;div&gt;&#123;% if not is_index %&#125;&#123;% include 'my-copyright.swig' %&#125;&#123;% endif %&#125;&lt;/div&gt; 保存 在执行hexo g和hexo d前要确保你的文章开头添加属性copyright: true，添加版权的代码才会有效（你可以把这个属性添加到文章模板里），然后执行完命令后，打开你的博客验证一下就OK了。 可以来我的网站看效果，https://itwalking.top]]></content>
      <categories>
        <category>技术教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客NexT主题不蒜子统计]]></title>
    <url>%2Fpage%2Fm30t12.html</url>
    <content type="text"><![CDATA[关于NexT的主题的一些基本设置，参考的是这篇文章https://www.jianshu.com/p/3a05351a37dc，其中对于不蒜子的统计我做了一些小的修改，使他更加灵活。 对于页脚的访客量统计和人数统计代码增加了判断，可以根据配置文件动态配置是否展示 1234567891011121314151617&lt;div&gt;&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;&#123;% if theme.busuanzi_count.site_pv %&#125;&lt;span id="busuanzi_container_site_pv" style='display:none'&gt; 自2019.05.24起 本站总访问量 &lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt; 次 &#123;% if theme.busuanzi_count.site_uv %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &#123;% endif %&#125;&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.busuanzi_count.site_uv %&#125; &lt;span id="busuanzi_container_site_uv" style='display:none'&gt; 有&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人看过我的博客啦 &lt;/span&gt;&#123;% endif %&#125;&lt;/div&gt; 主题配置文件里有对不蒜子的配置： 12345678910111213141516busuanzi_count: # count values only if the other configs are false enable: false # custom uv span for the whole site site_uv: false site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: false page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; page_pv_footer: 还有对每篇文章的阅读量统计，也是使用的配置文件变量，如下： 12345&#123;% if theme.busuanzi_count.page_pv %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt;次阅读&#123;% endif %&#125; 用的是主题配置文件的变量，不是原文中那样设置形参，调用是传参，这样不够灵活，用配置文件更加方便。 另外我发现不蒜子对于每篇文章的阅读量统计好像不是那么好，有时候过一段时间访问这篇文章的时候发现阅读量又变成啦1，访客量到时没有问题。于是我就换成了leanCould来统计每篇文章的阅读量。NexT主题也支持这个。 首先在leanCould注册账号，然后创建应用，在应用下创建class命名为Counter（必须），然后在设置-安全中心-web安全域名里把你的网站域名写上，保存，然后在设置-应用key里复制app-id和app-key，复制到NexT的主题配置文件里,找到如下配置复制进去就OK了。 12345leancloud_visitors: enable: true app_id: app_key: 执行hexo g，hexo d访问你的网站看一下吧。当然你可以在这个平台手动修改阅读量。]]></content>
      <categories>
        <category>技术教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改Hexo自动生成的HTML文件名]]></title>
    <url>%2Fpage%2Fm29w17.html</url>
    <content type="text"><![CDATA[导读我们在使用Hexo框架生成静态博客时，其实是将你写好的.md文件输出成HTML文件进行渲染，其中HTML的文件名称就是.md的文件名称。 而我们为了编辑文章方便，为了通过文件名就知道这是哪篇文章，通常是把.md文件命名成中文的甚至是文章的标题，那么生成HTML文件时也就是中文的文件名了。 例如：钢铁是怎么炼成的.md经过hexo g命令会生成钢铁是怎么炼成的.html；执行hexo d命令会将文件推送到你的仓库，那么你访问这篇章时，对应的地址栏就是http://xxxx/.../钢铁是怎么炼成的.html，这样看起来很别扭，对搜索引擎也不友好。 那么我们如何修改为以数字加字母命名的HTML呢？今天我们就来探究一下。 （1）修改生成HTML时的命名策略我们从Hexo是基于Node.js的，Hexo生成HTML文件这句话的到启发，Hexo肯定会获取文件夹下的所有.md文件生成HTML文件，命名格式xxx.md–&gt;xxx.html，然后肯定会创建目录存放HTML文件。 这时候我们会想，我们是不是可以在Hexo生成HTML文件时，修改HTML的命名策略，即将原始的命名方式改为我们自定义的命名方式？ 有了思路说干就干。于是去Hexo的各个文件里去找，它是在哪转换文件的。当我找了好几个文件后，我放弃了，文件太多了，太难找了，无异于大海捞针。在hexo模块里找了很久也没找到。。。 （2）修改HTML文件名既然刚才那种方法行不通，那么我们就另辟蹊径，在Hexo生成HTML文件后，再去修改文件名。JS怎么获取目录下的所有文件呢？搜了一下说Node.js可以，刚好Hexo是基于Node.js的。于是任意目录下（除hexo目录）创建rename.js文件如下，其中新的文件名生成策略可以自己定义。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//引入fs操作文件var fs = require('fs');//引入jqueryvar join = require('path').join;var jsdom = require('jsdom');const &#123;JSDOM&#125; = jsdom;const &#123;document&#125; = (new JSDOM('&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;')).window;global.document = document;global.window = document.defaultView;global.jQuery = require('jquery')(window);const $ = require('jquery')(window);var eng = ['a','b','c','d','e','f','g','h','i','j'];//生成随机6位数字字母 全路径新文件名function getNewNameRandom(_file)&#123; var fiveInt = Math.floor(Math.random()*89999+10000);//无五位随机数 var eng_index = Math.floor(Math.random()*10+1);//一位字母 return _file.substr(0,_file.lastIndexOf('\\')+1) + eng[eng_index-1] + fiveInt + ".html";//新文件名，全路径&#125;function getAllFiles(jsonPath)&#123; let jsonFiles = []; function findJsonFile(path)&#123; let files = fs.readdirSync(path); files.forEach(function (item, index) &#123; let fPath = join(path,item); let stat = fs.statSync(fPath); if(stat.isDirectory() === true) &#123; findJsonFile(fPath); &#125; if (stat.isFile() === true) &#123; jsonFiles.push(fPath); &#125; &#125;); &#125; findJsonFile(jsonPath); console.log(jsonFiles);//指定目录下的文件，包括子目录 return jsonFiles;&#125;function doFileRename()&#123; var jsonFiles = getAllFiles("F:/static/page");//生成的HTML文件 for(var i=0;i&lt;jsonFiles.length;i++)&#123; var _file = jsonFiles[i]; var newName = getNewNameRandom(_file);//新文件名，全路径 console.log(newName) fs.rename(_file,newName,function(err)&#123;//重命名 if(err)&#123; console.log("重命名失败"); &#125;else&#123; console.log("重命名成功"); &#125; &#125;) &#125;&#125;doFileRename(); 然后在这个JS所在目录打开命令行，执行node rename.js 看日志，是全部成功了，找到对应目录，真的成功了。 存在的问题hexo g时，又会生成原来的那样中文命名的HTML，我们重命名的还在（执行hexo clean就不在了），这不是我们想要的，或许你会说，再执行一次node rename.js，这不是我想要的，因为，这样执行每次原来的文章页面的名字都会变，我不知道这会不会影响SEO，即时不会也不想这样，因为加入别人收藏了你的文章链接，但你的文章HTML名字变了，拿别人收藏的就无效了啊。 所以这种方式会存在这个最严重的问题。 （3）Base64生成文件名修改JS代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//引入fs操作文件var fs = require('fs');//引入jqueryvar join = require('path').join;var jsdom = require('jsdom');const &#123;JSDOM&#125; = jsdom;const &#123;document&#125; = (new JSDOM('&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;')).window;global.document = document;global.window = document.defaultView;global.jQuery = require('jquery')(window);const $ = require('jquery')(window);var eng = ['a','b','c','d','e','f','g','h','i','j'];//文件名Base64后 根据算法从编码中取6位作为新文件名function getNewNameBase64(_file)&#123; var fileName = _file.substr(_file.lastIndexOf('\\')+1,_file.length);//文件名 var fi_bs64 = Buffer.from(fileName.substr(0,fileName.lastIndexOf('.'))).toString('base64')//转成base64编码 var arr = fi_bs64.split(""); var len = arr.length; var fis = ""; for(var i=1;i&lt;=6;i++)&#123; var s1 = arr[Math.floor(len/(2*i))]; if(s1=='/'||s1=='+')&#123; var eng_index = Math.floor(Math.random()*10+1); s1 = eng[eng_index-1]; &#125; fis = fis + s1; &#125; console.log(fis) return _file.substr(0,_file.lastIndexOf('\\')+1) + fis + ".html";&#125;function getAllFiles(jsonPath)&#123; let jsonFiles = []; function findJsonFile(path)&#123; let files = fs.readdirSync(path); files.forEach(function (item, index) &#123; let fPath = join(path,item); let stat = fs.statSync(fPath); if(stat.isDirectory() === true) &#123; findJsonFile(fPath); &#125; if (stat.isFile() === true) &#123; jsonFiles.push(fPath); &#125; &#125;); &#125; findJsonFile(jsonPath); console.log(jsonFiles);//指定目录下的文件，包括子目录 return jsonFiles;&#125;function doFileRename()&#123; var jsonFiles = getAllFiles("F:/static/page");//生成的HTML文件 for(var i=0;i&lt;jsonFiles.length;i++)&#123; var _file = jsonFiles[i]; var newName = getNewNameBase64(_file);//新文件名，全路径 console.log(newName) fs.rename(_file,newName,function(err)&#123;//重命名 if(err)&#123; console.log("重命名失败"); &#125;else&#123; console.log("重命名成功"); &#125; &#125;) &#125;&#125;doFileRename(); 效果 看日志，是全部成功了 找到对应目录，真的成功了。 存在的问题这种方法解决了上面那个方法存在的问题，即每次执行node rename.js只要原文件名不变，生成的新文件名不变。但是需要限制文件名不能变，否则新文件名还是会变。还有一点不能重复执行node rename.js，因为会根据新的再次生成新的。 小结第2、3种方式都需要注意的是，1、新名字的生成规则，要保证唯一性，不能重复2、每次hexo g之后hexo d之前，要执行node rename.js3、不要重复执行4、第一种不太可行，推介第二种 （4）修改文件生成规则以上两种方式都需要我们来写代码，而且要手动执行node rename.js对于这么懒的我来说很不方便，有没有更好的办法？答案是肯定的。 我们可以找到Hexo的根配置文件_config.yml，打开它，找到下图这个我把他改成这样了，page是目录，执行hexo g会在public下生成，我让生成的HTML文件都放在page下，:fileName.html是HTML的命名格式，其中fileName是个变量。这个变量从哪来？从你的.md文件里，如下图，在你的文章头部增加这个变量并指定一个值，这就是生成HTML时的文件名，注意也是不要和其他文件重复也就是说，你的每篇文章只要头部加了这个属性，并赋值且确保唯一就OK了，不用像上面那两种方式那样麻烦了。只样在执行hexo g后就变成这样了 执行hexo d后访问我的网站就是这样了 为了避免忘记在写文章时写fileName属性，我们可以修改模板，在scaffolds目录下有三个模板在模板添加fileName属性 存在的问题需要手动写文件的名字，且要保证唯一，但是比较方便 总结推荐使用第3和第4种，第3种主要就是解决每次执行hexo g后生成的HTML文件名不变（前提是.md文件名不变），但不要忘了执行node rename.js，第4种只要自己有一个自己的命名规范就好了，比如：今天是五月m，日期29，周三w，时间是17点，文件名就可以就是m29w17。 如果大家知道在Hexo生成HTML得时候就可以改或者有别的好办法，可以留言告诉我，谢谢。 本文以及本文提供的方法均为作者原创，自己摸索出来的，转载请注明出处，感谢！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客Next主题,网页背景及页面进度条炫酷特效]]></title>
    <url>%2Fpage%2Fa92117.html</url>
    <content type="text"><![CDATA[为你的Hexo博客增加炫酷的特效，这里我使用的是简约的Next主题，在这个主题下给网页加载时进度条特效，网页背景特效。 #加载页面进度特效 页面加载过程中顶部的进度条。在主题配置文件里找到 pace: true 设置成true 然后设置进度条的主题 pace_theme: pace-theme-minimal 可选的进度条主题 pace-theme-big-counter 右上角很大的百分比 pace-theme-bounce 右上角球跳动 pace-theme-barber-shop 整个页面蓝白相间刮过 pace-theme-center-atom 页面中间有原子转圈并有百分比 pace-theme-center-circle 一个圆写着百分比 左右翻转着 pace-theme-center-radar 页面中间有个大的WiFi图标转圈 pace-theme-center-simple 中间小段蓝色进度条 无百分比 pace-theme-corner-indicator 右上角三角 里面有圆再转 pace-theme-fill-left 整个页面蓝色刮过 浅颜色 pace-theme-flash 右上角小圆圈 不闭合的 转圈 pace-theme-loading-bar 页面中间粗的进度条 百分比 pace-theme-mac-osx 页面上方粗的蓝色进度条 同时整个页面灰色进度 pace-theme-minimal 最简单的，页面顶部蓝线进度条。细的 #网页背景特效 喜欢哪个设置成true就行，可以设置多个 Canvas-nest 帆布巢 跟着鼠标的灰色菱形 canvas_nest: false three_waves 三波 波动的灰色小球 three_waves: true canvas_lines 帆布线 页面背景 有灰线链接 鼠标移动也动 canvas_lines: false canvas_sphere 帆布球 页面中间辐射的黑线 canvas_sphere: false 我试了一下感觉太晃眼了，就没弄了 看自己喜好吧]]></content>
      <categories>
        <category>技术教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx重定向URI之rewrite和alias]]></title>
    <url>%2Fpage%2Fa92812.html</url>
    <content type="text"><![CDATA[熟悉Nginx的同学都知道Nginx可以用来做负载均衡和反向代理，非常好用。做前后端分离也是非常的方便。今天我们就来说一下，用Nginx做前后端分离时如何做URI重定向？ 什么是URI重定向？ 就是说访问某一个或者某一规则URI时由Nginx的配置来决定重定向到另外一个或一类URI。 有啥用呢？ 其中一个作用就是可以将请求映射到真实目录。具体啥意思呢？ 比如我们的URL是http://www.abc.com/ITwalking/page/index.html而index.html在我们的系统目录 D:/resources/ITwalking/page/下 这时我们可以这样配置location: 123location /ITwalking &#123; root D:/resources/;&#125; 用root这种方式配置的话，location后面的ITwalking是作为系统目录的， 即D:/resources/下要有/ITwalking/page这层目录。 这种配置是没问题的。 但假如我们的D:/resources/下直接就是page， 然后下面直接就是文件呢，中间没 有/ITwalking这层目录，怎么办呢？你可能会想，新建个ITwalking把page及其中的文件移动到里面，然后用上面的配置不就可以了吗。 可以，但没必要！ 非常没必要，因为我们的resources/page目录可能是从git上clone的，如果我们新建目录移动进去，那我们是不是修改了本地git仓库，那我们提交代码或更新时咋办？再移出去？多麻烦啊。(因为我们请求后台必须要加/ITwalking的) 为了解决这个问题，我们可以用 Nginx 的 alias 指令或者 rewrite 指令。 1、alias指令用来重置当前文件的目录，lacation后面的是虚拟目录 1234location /ITwalking/ &#123; #使用 nginx alias 指令 alias D:/resources/page/;&#125; 这样，当URL为 http://www.abc.com/ITwalking/page/index.html时， 会将此请求重定向到 D:/resources/page/index.html 此时的ITwalking是虚拟目录，对此目录的访问重置到 D:/resources/page/ 2、rewrite重定向，需要配合root指令一起使用 12345location /ITwalking/ &#123; root D:/resources/page/; #使用 nginx rewrite 指令 rewrite ^/ITwalking/(.*?)$ /$1 break;&#125; 这两种效果是一样的。^/ITwalking/(.*?)$是正则，表示满足这个正则的请求，都重定向到D:/resources/page/下，/$1重定向的地址，break终止匹配。 rewrite是针对http请求的，它里面的路径是网址里面的地址，rewrite做的是地址间的转换。而root和alias是系统文件路径的设置。区别是，root用来设置根目录，而alias用来重置当前文件的目录。 关于rewrite和alias重定向的例子先说到这，这也是我实际遇到的，这两种方式完美的满足了我的需求。 二者的详细用法，后续的文章会详细讲解。]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>前后端分离</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客Next主题优化配置记录]]></title>
    <url>%2Fpage%2Fa20192.html</url>
    <content type="text"><![CDATA[这篇文章记录了使用Hexo Next主题搭建博客时的一些主题优化和配置的一些小方法，其中参考了很多博主的文章，在这里先谢谢各位，有参考到的文中会标明并给出链接。修改文章模板 scaffolds/,这个目录下有三个文件 123draft.mdpage.mdpost.md 这是三个模板文件当我们用hexo new “title”创建文章时，默认使用的是post.md，hexo new 后面可跟post,page,draft三个参数，默认使用post参数，可修改这三个文件的模板头信息。 给原创文章添加版权信息 最近，我发现我之前发表的原创文章，被别人到处转载，这些人转载时根本没有经过我的同意，没有询问过我，更没有在文章中注明转载链接、出处，令我很是气愤。 hexo next主题怎么添加版权信息呢？可以参考https://www.jianshu.com/p/93170e7413e9 看效果可以来我的网站http://itwalking.top 网站SEO优化 参考了这位大神的文章https://blog.csdn.net/qq_35661627/article/details/81267016 持续更新中…]]></content>
      <categories>
        <category>经验分享</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
        <tag>next主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建hexo静态博客框架全过程及踩的坑]]></title>
    <url>%2Fpage%2Fa92817.html</url>
    <content type="text"><![CDATA[网上有很多博客写了hexo的操作教程，但是都很生硬，我找了好几篇按照博客上写的一步一步操作，总是会遇到这样活那样的错误，导致最终卡主做不下去。而且很多博客只是一味的堆积教程、步骤，只字不提过程中会报什么错，咋解决，导致我很苦恼。 所以这篇文章将记录我按照别人的博客搭建hexo博客静态框架所遇到的问题以及解决方法。 首先需要安装git和node.js，这是必须的，因为hexo是基于node的，而我们需要用git将网站托管到GitHub。安装这里不再多说。 安装完成后，在你电脑的D盘或别的盘，新建个目录如blog，在你建的目录下右键打开git bash，执行 npm install -g hexo-cli，安装hexo客户端，执行命令后效果如下 1234567$ npm install -g hexo-cliC:\Users\yapeng\AppData\Roaming\npm\hexo -&gt; C:\Users\yapeng\AppData\Roaming\npm\node_modules\hexo-cli\bin\hexonpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules\hexo-cli\node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)+ hexo-cli@1.1.0updated 1 package in 34.207s 然后执行 hexo init myblg，myblg是自定义的，会生成个目录 12345678910111213141516171819$ hexo init myblgINFO Cloning hexo-starter to D:\blog\myblgCloning into &apos;D:\blog\myblg&apos;...remote: Enumerating objects: 3, done.remote: Counting objects: 100% (3/3), done.remote: Compressing objects: 100% (3/3), done.remote: Total 71 (delta 0), reused 0 (delta 0), pack-reused 68Unpacking objects: 100% (71/71), done.Submodule &apos;themes/landscape&apos; (https://github.com/hexojs/hexo-theme-landscape.git) registered for path &apos;themes/landscape&apos;Cloning into &apos;D:/blog/myblg/themes/landscape&apos;...remote: Enumerating objects: 1, done.remote: Counting objects: 100% (1/1), done.remote: Total 896 (delta 0), reused 0 (delta 0), pack-reused 895Receiving objects: 100% (896/896), 2.55 MiB | 192.00 KiB/s, done.Resolving deltas: 100% (479/479), done.Submodule path &apos;themes/landscape&apos;: checked out &apos;73a23c51f8487cfcd7c6deec96ccc7543960d350&apos;INFO Install dependenciesnpm WARN deprecated core-js@1.2.7: core-js@&lt;2.6.8 is no longer maintained. Please, upgrade to core-js@3 or at least to actual version of core-js@2.INFO Catch you later 然后$ cd myblg/ 再然后执行$ npm install 12345$ npm installnpm notice created a lockfile as package-lock.json. You should commit this file.audited 4698 packages in 4.572sfound 3 vulnerabilities (2 low, 1 moderate) run `npm audit fix` to fix them, or `npm audit` for details 发现有提示，然后根据提示继续执行$ npm audit fix 123456$ npm audit fixup to date in 3.725sfixed 0 of 3 vulnerabilities in 4698 scanned packages 2 vulnerabilities required manual review and could not be updated 1 package update for 1 vuln involved breaking changes (use `npm audit fix --force` to install breaking changes; or refer to `npm audit` for steps to fix these manually) 继续根据提示$ npm audit fix --force 12345678$ npm audit fix --forcenpm WARN using --force I sure hope you know what you are doing.+ hexo-renderer-marked@1.0.1updated 2 packages in 5.736sfixed 1 of 3 vulnerabilities in 4698 scanned packages 2 vulnerabilities required manual review and could not be updated 1 package update for 1 vuln involved breaking changes (installed due to `--force` option) 然后执行hexo generate或$ hexo g，生成静态博客 1234567891011121314151617181920212223242526272829303132$ hexo gINFO Start processingINFO Files loaded in 440 msINFO Generated: index.htmlINFO Generated: archives/index.htmlINFO Generated: fancybox/blank.gifINFO Generated: fancybox/fancybox_loading.gifINFO Generated: fancybox/fancybox_overlay.pngINFO Generated: fancybox/fancybox_sprite.pngINFO Generated: fancybox/jquery.fancybox.cssINFO Generated: fancybox/fancybox_loading@2x.gifINFO Generated: fancybox/fancybox_sprite@2x.pngINFO Generated: archives/2019/index.htmlINFO Generated: archives/2019/05/index.htmlINFO Generated: fancybox/helpers/jquery.fancybox-buttons.cssINFO Generated: css/fonts/fontawesome-webfont.eotINFO Generated: css/style.cssINFO Generated: js/script.jsINFO Generated: fancybox/jquery.fancybox.pack.jsINFO Generated: fancybox/helpers/jquery.fancybox-media.jsINFO Generated: fancybox/helpers/jquery.fancybox-thumbs.jsINFO Generated: fancybox/helpers/jquery.fancybox-buttons.jsINFO Generated: fancybox/helpers/jquery.fancybox-thumbs.cssINFO Generated: fancybox/helpers/fancybox_buttons.pngINFO Generated: css/fonts/fontawesome-webfont.woffINFO Generated: css/fonts/FontAwesome.otfINFO Generated: css/fonts/fontawesome-webfont.ttfINFO Generated: css/fonts/fontawesome-webfont.svgINFO Generated: 2019/05/23/hello-world/index.htmlINFO Generated: css/images/banner.jpgINFO Generated: fancybox/jquery.fancybox.jsINFO 28 files generated in 928 ms 然后执行$ hexo s，启动服务 123$ hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 说明正常启动 访问localhost:4000正常，可以看到hexo的默认页面 我们要用github托管我们的网站，所以要在github注册账号，注册完后创建一个仓库，名字叫XXXX.github.io，其中XXXX就是你的GitHub的用户名，一定要这样。 然后安装deployer-git，用来将hexo生成的文件推到GitHub 执行npm install hexo-deployer-git --save 1234567$ npm install hexo-deployer-git --savenpm WARN babel-eslint@10.0.1 requires a peer of eslint@&gt;= 4.12.1 but none is installed. You must install peer dependencies yourself.+ hexo-deployer-git@1.0.0added 59 packages from 48 contributors and audited 6951 packages in 16.659sfound 2 low severity vulnerabilities run `npm audit fix` to fix them, or `npm audit` for details 意思是 babel-eslint@10.0.1需要 eslint@&gt;= 4.12.1 ，但是没安装，需要手动安装，不用管。 关键的一步，修改配置_config.yml文件，替换成你自己的github仓库地址，冒号后面一定要有空格！！！ 记得后面有.git (这是我已经部署到GitHub后的，可能和你现在的不太一样) 1234deploy: type: git repo: https://github.com/biggerboy/biggerboy.github.io.git branch: master 先不管，继续执行hexo clean 123$ hexo cleanINFO Deleted database.INFO Deleted public folder. 继续hexo generate或hexo g生成静态博客系统 1234567891011121314151617181920212223242526272829303132$ hexo generateINFO Start processingINFO Files loaded in 491 msINFO Generated: index.htmlINFO Generated: archives/index.htmlINFO Generated: fancybox/blank.gifINFO Generated: fancybox/fancybox_loading.gifINFO Generated: fancybox/jquery.fancybox.cssINFO Generated: fancybox/fancybox_loading@2x.gifINFO Generated: fancybox/fancybox_overlay.pngINFO Generated: fancybox/fancybox_sprite.pngINFO Generated: archives/2019/05/index.htmlINFO Generated: fancybox/fancybox_sprite@2x.pngINFO Generated: archives/2019/index.htmlINFO Generated: css/fonts/fontawesome-webfont.eotINFO Generated: fancybox/helpers/jquery.fancybox-buttons.cssINFO Generated: js/script.jsINFO Generated: fancybox/jquery.fancybox.pack.jsINFO Generated: fancybox/helpers/jquery.fancybox-thumbs.cssINFO Generated: fancybox/helpers/jquery.fancybox-buttons.jsINFO Generated: css/style.cssINFO Generated: fancybox/helpers/jquery.fancybox-media.jsINFO Generated: css/fonts/fontawesome-webfont.woffINFO Generated: fancybox/helpers/jquery.fancybox-thumbs.jsINFO Generated: fancybox/helpers/fancybox_buttons.pngINFO Generated: css/fonts/fontawesome-webfont.svgINFO Generated: css/fonts/fontawesome-webfont.ttfINFO Generated: css/fonts/FontAwesome.otfINFO Generated: css/images/banner.jpgINFO Generated: 2019/05/23/hello-world/index.htmlINFO Generated: fancybox/jquery.fancybox.jsINFO 28 files generated in 930 ms 继续执行$ hexo deploy发布，报错继续往下，不报错就忽略对报错的处理 1234567891011121314151617181920212223242526272829$ hexo deployFATAL bad indentation of a mapping entry at line 83, column 9: branch: master ^YAMLException: bad indentation of a mapping entry at line 83, column 9: branch: master ^ at generateError (D:\blog\myblg\node_modules\js-yaml\lib\js-yaml\loader.js:167:10) at throwError (D:\blog\myblg\node_modules\js-yaml\lib\js-yaml\loader.js:173:9) at readBlockMapping (D:\blog\myblg\node_modules\js-yaml\lib\js-yaml\loader.js:1107:7) at composeNode (D:\blog\myblg\node_modules\js-yaml\lib\js-yaml\loader.js:1359:12) at readDocument (D:\blog\myblg\node_modules\js-yaml\lib\js-yaml\loader.js:1519:3) at loadDocuments (D:\blog\myblg\node_modules\js-yaml\lib\js-yaml\loader.js:1575:5) at Object.load (D:\blog\myblg\node_modules\js-yaml\lib\js-yaml\loader.js:1596:19) at Hexo.yamlHelper (D:\blog\myblg\node_modules\hexo\lib\plugins\renderer\yaml.js:7:15) at Hexo.tryCatcher (D:\blog\myblg\node_modules\bluebird\js\release\util.js:16:23) at Hexo.&lt;anonymous&gt; (D:\blog\myblg\node_modules\bluebird\js\release\method.js:15:34) at Promise.then.text (D:\blog\myblg\node_modules\hexo\lib\hexo\render.js:61:21) at tryCatcher (D:\blog\myblg\node_modules\bluebird\js\release\util.js:16:23) at Promise._settlePromiseFromHandler (D:\blog\myblg\node_modules\bluebird\js\release\promise.js:512:31) at Promise._settlePromise (D:\blog\myblg\node_modules\bluebird\js\release\promise.js:569:18) at Promise._settlePromise0 (D:\blog\myblg\node_modules\bluebird\js\release\promise.js:614:10) at Promise._settlePromises (D:\blog\myblg\node_modules\bluebird\js\release\promise.js:694:18) at _drainQueueStep (D:\blog\myblg\node_modules\bluebird\js\release\async.js:138:12) at _drainQueue (D:\blog\myblg\node_modules\bluebird\js\release\async.js:131:9) at Async._drainQueues (D:\blog\myblg\node_modules\bluebird\js\release\async.js:147:5) at Immediate.Async.drainQueues [as _onImmediate] (D:\blog\myblg\node_modules\bluebird\js\release\async.js:17:14) at runCallback (timers.js:705:18) at tryOnImmediate (timers.js:676:5) 检查配置文件，改成如下 repo改成repository，冒号后面一定要有空格！！！ 1234deploy: type: git repository: https://github.com/biggerBoy/biggerBoy.github.io.git branch: master 再执行$ hexo deploy什么都不输出，或报错都是不成功，若输出如下，就是成功 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182$ hexo deployINFO Deploying: gitINFO Setting up Git deployment...Initialized empty Git repository in D:/blog/myblg/.deploy_git/.git/[master (root-commit) de8dd58] First commit 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 placeholderINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...warning: LF will be replaced by CRLF in 2019/05/23/hello-world/index.html.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in archives/2019/05/index.html.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in archives/2019/index.html.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in archives/index.html.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in css/style.css.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in fancybox/helpers/jquery.fancybox-buttons.css.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in fancybox/helpers/jquery.fancybox-buttons.js.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in fancybox/helpers/jquery.fancybox-media.js.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in fancybox/helpers/jquery.fancybox-thumbs.css.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in fancybox/helpers/jquery.fancybox-thumbs.js.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in fancybox/jquery.fancybox.css.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in fancybox/jquery.fancybox.js.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in fancybox/jquery.fancybox.pack.js.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in index.html.The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in js/script.js.The file will have its original line endings in your working directory.[master 0c627f1] Site updated: 2019-05-23 14:07:10 29 files changed, 5785 insertions(+) create mode 100644 2019/05/23/hello-world/index.html create mode 100644 archives/2019/05/index.html create mode 100644 archives/2019/index.html create mode 100644 archives/index.html create mode 100644 css/fonts/FontAwesome.otf create mode 100644 css/fonts/fontawesome-webfont.eot create mode 100644 css/fonts/fontawesome-webfont.svg create mode 100644 css/fonts/fontawesome-webfont.ttf create mode 100644 css/fonts/fontawesome-webfont.woff create mode 100644 css/images/banner.jpg create mode 100644 css/style.css create mode 100644 fancybox/blank.gif create mode 100644 fancybox/fancybox_loading.gif create mode 100644 fancybox/fancybox_loading@2x.gif create mode 100644 fancybox/fancybox_overlay.png create mode 100644 fancybox/fancybox_sprite.png create mode 100644 fancybox/fancybox_sprite@2x.png create mode 100644 fancybox/helpers/fancybox_buttons.png create mode 100644 fancybox/helpers/jquery.fancybox-buttons.css create mode 100644 fancybox/helpers/jquery.fancybox-buttons.js create mode 100644 fancybox/helpers/jquery.fancybox-media.js create mode 100644 fancybox/helpers/jquery.fancybox-thumbs.css create mode 100644 fancybox/helpers/jquery.fancybox-thumbs.js create mode 100644 fancybox/jquery.fancybox.css create mode 100644 fancybox/jquery.fancybox.js create mode 100644 fancybox/jquery.fancybox.pack.js create mode 100644 index.html create mode 100644 js/script.js delete mode 100644 placeholderEnumerating objects: 46, done.Counting objects: 100% (46/46), done.Delta compression using up to 4 threads.Compressing objects: 100% (36/36), done.Writing objects: 100% (46/46), 507.67 KiB | 5.46 MiB/s, done.Total 46 (delta 3), reused 0 (delta 0)remote: Resolving deltas: 100% (3/3), done.To https://github.com/biggerboy/biggerboy.github.io.git + 07ed017...0c627f1 HEAD -&gt; master (forced update)Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;https://github.com/biggerboy/biggerboy.github.io.git&apos;.INFO Deploy done: git 说明成功！！！！ 访问http://biggerboy.github.io后如下，就是成功了。这是默认的主题，默认页面 到此，搭建完成，可以自己任意玩了。 以上这些命令，都是在git bash下执行的， 创建文章：hexo new “文章名”， 会在\source\_posts下生成一个.md文件，打开它编辑你的文章就行了，这个文件是用Markdown编辑器编辑的。 写完文章后，在git bash里分别执行三个命令hexo clean，hexo g， hexo d hexo claen可以不执行 这时候再访问你的网站就有你新写的文章了。 还可以增加搜索功能，评论功能，订阅功能，访客量统计，个性化导航栏，更换主题]]></content>
      <categories>
        <category>技术教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类是如何默认继承Object的？]]></title>
    <url>%2Fpage%2Fa92871.html</url>
    <content type="text"><![CDATA[前言学过Java的同学都知道，Object是所有类的父类。但是你有没有这样的疑问，我并没有写extends Object，它是怎么默认继承Object的呢？ 那么今天我们就来看看像Java这种依赖于虚拟机的编程语言是怎样实现默认继承Object的，以及Java编译器和JVM到底是如何做的？ 继承自Object验证首先我们来验证一下Object是不是所有类的父类，随便新建一个Java类，如下图： 从上面的代码可以看出，new MyClass()打点之后可以选择调用的方法有很多，我们定义的MyClass类里面只有一个main方法，那这些方法哪来的，显然是Object里声明的，故MyClass类的父类就是Object，因此，在MyClass中可以使用Object类的public或protected资源。 另外，当A类继承MyClass类时，通过打点也可以调到Object内的方法，这是继承的传递，好比Object是MyClass的“父亲”，MyClass是A类的“父亲”，Object是A类的“爷爷”，间接的继承了Object。 因此，Object是超类，是所有类的父类。 推测可能的原因要了解Java类是如何默认继承Object的？的原因其实并不需要知道JVM的实现细节。只需了解一下对于这种虚拟机程序的基本原理即可。一般对于这种靠虚拟机运行的语言（如Java、C#等）会有两种方法处理默认继承问题。 编译器处理在编译源代码时，当一个类没有显式标明继承的父类时，编译器会为其指定一个默认的父类（一般为Object），而交给虚拟机处理这个类时，由于这个类已经有一个默认的父类了，因此，VM仍然会按照常规的方法像处理其他类一样来处理这个类。对于这种情况，从编译后的二进制角度来看，所有的类都会有一个父类（后面可以以此依据来验证）。 JVM处理编译器仍然按照实际代码进行编译，并不会做额外的处理，即如果一个类没有显式地继承于其他类时，编译后的代码仍然没有父类。然后由虚拟机运行二进制代码时，当遇到没有父类的类时，就会自动将这个类看成是Object类的子类（一般这类语言的默认父类都是Object）。 验证结论从上面两种情况可以看出，第1种情况是在编译器上做的文章，也就是说，当没有父类时，由编译器在编译时自动为其指定一个父类。第2种情况是在虚拟机上做文章，也就是这个默认的父类是由虚拟机来添加的。 那么Java是属于哪一种情况呢？其实这个答案很好得出。只需要随便找一个反编译工具，将.class文件进行反编译即可得知编译器是如何编译的。 就以上面代码为例，如果是第1种情况，就算MyClass没有父类，但由于编译器已经为MyClass自动添加了一个Object父类，所以，在反编译后得到的源代码中的MyClass类将会继承Object类的。如果不是这种情况，那么就是第2种情况。 那么实际情况是什么样的呢？现在我们就将MyClass.class反编译看看到底如何。 jd-gui反编： 使用JDK自带的工具（javap）反编译 CMD命令行下执行：javap MyClass&gt;MyClass.txt 可以看出实际的反编译后的文件中并没有extends Object，使用排除法，因此是第2情况。 这样来推导出的结论是第2种情况，但事实真的如此吗？为什么网上还有说反编译后的是有extends Object字样？ JDK版本问题？ 猜想是JDK版本的问题，于是把JDK版本切换到7，使用jd-gui和javap反编译，接果和使用JDK8反编译后的结果一样，也都没有extends Object。 继续换版本，昨晚在宿舍准备到Oracle官网下载JDK 6，但是死活下不来，今早到公司后第一件事就是下载，很顺利，安装后把JDK版本切换到JDK 6。 仍然在CMD窗口执行javap MyClass&gt;MyClass.txt，得到的TXT文件内容如下： what？竟然有extends Object，jd-gui反编译后的依然没有。即，JDK 6之前使用javap反编译后的MyClass类显式的继承Object，JDK 7以后没有；jd-gui反编译后的不管JDK版本如何始终没有。我们以java自带的工具为准。 总结那么就是说JDK 6之前是编译器处理，JDK 7之后是虚拟机处理。 但是仔细想想我们在编辑器里（IDE）打点时就能列出Object类下的方法，此时还没轮到编译器和jvm，编辑器就已经知道MyClass类的父类是Object类了，这是因为编辑器为我们做了一些智能处理。 【end】]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写给即将入职的你-软件工程之需求开发流程]]></title>
    <url>%2Fpage%2Fas82cx.html</url>
    <content type="text"><![CDATA[前言在这个春风得意马蹄疾，金三银四跳槽季的日子里，相信很多小伙伴都拿到了心仪的offer了吧，其中不乏有初入职场的同学。那么今天，我就从服务端的角度来给大家分享一些关于工作中开发流程的经验，希望初入职场的同学尽量少踩坑不背锅，能够顺利通过考核期。 进入公司你会发现，一般正规点的公司都会分很多部门，如开发部（科技部或研发部）、产品部（业务部）等，这两个部门是相互对等的，也就是说后者负责产品功能的创意、设计，产品的大方向，说白了就是负责提出产品需求，把控产品的定位和走向；而前者则是需求的受理者，负责从软件、技术层面来实现后者提出的需求。两个部门没有上下级的关系。 而对于我们程序员来说，做一个需求从接到需求到上线的完整流程大致如下： 需求分析（包括需求调研，需求讨论，需求确定，接口确认） 系统设计（设计该功能实现细节，要用到什么技术等） 系统实现（从软件代码技术层面实现功能） 功能测试（包括开发自测，提交测试，业务测试） 需求上线（业务验收，验收是否通过，代码是否回退） 需求分析从你拿到需求文档开始说起，你会看到需求文档至少包括2部分来阐述这个需求：需求背景和需求描述。 需求背景： 主要告诉你为什么会有这个需求，提这个需求的目的是什么。需求描述： 这才是这个需求的重点，主要告诉你要实现什么样的功能，做成什么样的效果，以及一些业务规则等，可能还会放几个页面的原型图，这就再好不过了。 这些都是业务部门经过深思熟虑、各级领导审核通过后的需求，才会到研发部门，研发部受理这个需求，分给你的组长或直接分给你。 言归正传，你接到需求，打开需求文档，开始看需求了。 1、快速通读可以先快速地通读一遍，了解需求的大致意思，对需求有个整体的把握，做到心中有数。 2、抓重点、记疑问然后第二遍，看细节，抓疑问点。这一遍，你可以看仔细点，把一些关键点认真看看理解一下，同时看的时候可能会发现需求有写的不明确的地方，或者需要确认的地方，或者你会有一些疑问，这个时候你可以把这些点记录下来，认真读完一遍之后，你记录了一些问题。 3、答疑解惑读完两遍之后，你有一些疑问。然后你可以找个时间拉上经理或需求负责人，开发组长，前后端开发人员，业务（提需求的业务人员，他是最了解需求的人）、测试负责人一起当面开个小会（能当面绝不群里聊），去解决你记录的疑问点，把这些需求里你认为写的不确定的地方弄清楚。这个过程就是答疑解惑。 在这个讨论过程中，定下来的业务规则务必要记录下来，会后可以发一封电子邮件，把需求确认的东西或者业务又新加的东西写在邮件里，提醒业务确认无误后让他更新需求文档，并且邮件抄送给一起开会的人。 为什么拉上这么多人呢？因为你有疑问的地方你的组长，经理等也可能有疑问，这种拍板钉钉的事不能只让你一个人知道，到时候做完了上线了，业务发现不想要那样的效果了赖账不承认了咋办。拉上测试是为了避免开发和测试理解需求上有偏差，避免测试写的测试案例和需求要求有出入。 为什么发邮件呢？做这一步也是为了规范开发流程以及留个底有个证据吧，防止以后问你为啥这样做，你就有据可依了。不然你单凭嘴说：当时讨论就这样定的。这样说服力不够啊。我们一定要做到，不甩锅也绝不无故背锅！ 4、准备材料需求讨论过程中如发现涉及其他系统，提出来，并确认下其他系统接口有没有提供好，并通过项目经理向其他系统要接口文档（系统间的文档收发，最好通过系统负责人，即使都是内部系统）；另外，如涉及到页面改动需要提供UI的，督促业务及时提供UI，防止延误需求上线。 为什么出UI？出UI的目的是严格按照UI图的尺寸、色值来做页面，防止到时候前端做好页面后业务又来扣这些细节，让你返工，还显得你干活不利索。假如有的公司根本没有UI设计师，那就提前和业务说好，做的时候让业务把把关，看是否复合他要的效果。 5、工作记录其次，针对该需求，写每日工作进度（日报）时，写上当前需求到了哪个阶段（如需求分析阶段，开发阶段等，具体到了哪个阶段，自己评估），以及当前遇到的阻碍等。这样如果有阻碍，即使是延误了上线，也不是自己的原因。 注意：1、系统间接口联调大概需要1-2天，复杂的接口可能需要更长的时间。系统联调最好放在系统设计前，这样可以发现接口返回内容是不是满足这个需求，并提出这个问题。如果你开发的时候用到这个接口的时候再联调才发现问题，那不是耽误时间了吗。 2、假如第一次调用该系统，还要注意开通系统间的网络，不然无法访问。开通网络当然也需要项目负责人来申请。而且一定要测试环境和生产环境的网络一并开通，开通后并测试是否真的已经开通。这样防止没有开通网络，上线后调不通，又临时火急火燎的发邮件申请开通网络，这样只会让你难堪，显得你这个人不够仔细。 系统设计需求分析，接口联调，开通网络等一些准备工作及杂事处理完后，就可以开始系统设计了或者边处理边进行系统设计（因为你等着出UI、开网都需要时间）。 系统设计就是来思考怎么来实现这个功能，实现流程是什么样的，要不要新增表或增加表字段，表结构如何设计，要写几个接口给前端，调用顺序是什么样的，返回什么样的数据，数据格式什么样的，可以和前端开发坐一块儿讨论。这些应该在你分析完需求后就有了一个大致的思路，然后现在提取需求的关键词、关键点作具体的详细设计。 系统设计也是很重要的一环，是在写代码之前定的目标，做的一个宏观规划。尽量不要边写代码边想怎么实现，这样会导致最后思路很乱写的代码也很乱。 建议最好画流程图，条件允许的情况下小组内评审下，找出不足。 在系统设计阶段如果需引入新技术，一定要考虑使用什么技术，技术的复杂度，成熟度等，为什么用这个技术，好处是什么。如果自己不敢确定用什么技术，可以找技术经理或比自己经验丰富的同事一起定一下。初入职场或经验颇少的同学，可以把自己的设计思路和他们说一下，让他们把把关。 系统实现这一步就是你最喜欢的写代码阶段了，写代码的一些规范不用我多说了吧，下载阿里的开发手册看看，或自己公司的开发规范。 业务代码一定要加注释，在关键步骤加上简单的注释，以便日后自己看或者其他同事接替你的时候能一目了然，看懂这代码是在干嘛，不至于背地里被吐槽被骂娘。很多时候一些同学自己写的代码，不加一行注释，时间长了自己看的时候都懵逼了。加必要的注释是程序员最最起码的修养。 在功能开发到近一半的时候，邮件给测试负责人并抄送相关人员，告知此需求已开发过半，目的提醒其写需求的测试案例，以免延误测试。这一点根据你们开发流程定，建议如此。 功能测试开发完成就进入功能测试阶段了，或开发完某一接口（给前端调用的）开发人员就可以边开发边测了。 1、开发自测开发人员对自己开发的功能自己测试，主要测试接口的逻辑，入参出参是否正确等，边开发边测，前后端可以一起测。 当整个功能都开发完成后，开发人员对该需求做整个流程的测试，针对可能出现问题的场景重点测试，当觉得本地测试的差不多的时候，可以把代码合并到测试环境再进行一次完整的测试。当觉得可以的时候，请小组组长发起走查代码，主要检查代码逻辑及代码规范等常见的显而易见的问题（毕竟旁观者清，自己写的代码可能看很久也发现不了问题），有问题就改一下，走查没问题了就可以提交给测试人员了。 这里走查可以记录到代码走查记录里，主要写走查负责人，开发人员，走查时间，需求名，走查发现的问题，是否解决，何时解决等。通过走查代码可以防止同样的问题再发生，或大家互相引以为戒。 2、提交测试自测完毕后，邮件给测试负责人及相关人员，邮件说明某某需求已经合并到某某分支，或已发布在某某测试环境，现在提测本需求，及时测试等等…并说明涉及到的功能和系统，以及主要的测试点。接下来你就配合测试人员啦，有bug改bug。 3、业务测试当测试人员测的差不多了，她们会邮件给业务人员。业务测完觉得没问题，那就等着上线吧。 需求上线需求上线前一定要检查你的代码完整性，把你的需求涉及到的SQL语句（如新增的系统参数，新增表结构等）、改动的配置文件（新增或修改配置）提交给运维。（重要！！！） 在需求上线的那天，你熬夜等上线（大部分都是晚上上线避开高峰期，也有的是灰度发布可以提前上）。当生产发完后，测试人员和业务人员会在生产验证，当业务说验收通过时，恭喜你可以回家了。如果有问题，你还得去查日志排查问题，然后解决，再上，再验证；如果问题太严重，你的代码就需要撤下来，暂时不上。 最后上线完毕后，将本次需求所有有关的文档打包归档，提交至你们的文档库或者类似confluence这样的开发管理平台，如果没有这些东西或没要求做这些，可以自己保存下来，以便以后查阅。 总结软件工程是一门学科，这里主要站在后端程序员的角度分享了自己总结的需求开发流程及开发过程中避免踩坑背锅的经验，可能写的有点粗略，或废话很多，可能有的公司没那么规范，也可能有的公司比这流程复杂多了，但是这里提到的需求分析、系统设计部分应该跟公司定的开发流程没关系，是开发人员自己的习惯和经验、自己给自己定的规范。还是那句话，我们程序员不甩锅也绝不无故背锅！ 【END】]]></content>
      <categories>
        <category>经验分享</category>
      </categories>
      <tags>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何向女朋友解释int==Integer为true]]></title>
    <url>%2Fpage%2Fh3s09b.html</url>
    <content type="text"><![CDATA[int==Integer为什么返回true先看现象吧 执行下面的代码及输出结果： 123456int a = 1;Integer b = 1;Integer c = new Integer(1);System.out.println(a==b);//trueSystem.out.println(a==c);//trueSystem.out.println(b==c);//false 通常大家对此的解释是，==对于基本类型来说比较的是值，对于引用类型来说比较的是引用，即指向的对象的内存地址。这样解释没错，b==c结果为false毋庸置疑，因为两个都是引用类型。但是为什么a==b（a==c）一个是基本类型一个是引用类型，比较的时候还是值比较呢？ 这个时候我们不妨把.java源文件编译后的.class文件使用反编译工具反编译成源码，看看虚拟机内部是如何处理a==b的。 .class文件使用jd-gui反编译后的： 123456int a = 1;Integer b = Integer.valueOf(1);Integer c = new Integer(1);System.out.println(a == b.intValue());System.out.println(a == c.intValue());System.out.println(b == c); 看到这想必大家都明白了吧，其实基本类型a和引用类型b比较时，引用类型b调用自身的intValue()方法获取Integer实际表示的int类型的值，即a == b.intValue()还是两个int类型的变量进行值比较。符合上述：==对于基本类型来说比较的是值，对于引用类型来说比较的是引用，即指向的对象的内存地址。 基本类型及引用类型在内存中的存储方式说到这，还要解释下为什么两个引用类型的值一样而引用不一样以及基本变量为什么是值比较。 其实基本变量int a在内存里只有一份，保存在栈（保存基本类型的变量数据及引用类型的引用）中，Integer b和Integer c中的int值都指向栈中同一个int，不会重新在栈中创建相同的int值。 而对于Integer b和Integer c，其实例是保存在堆（保存所有new出来的对象）中，虽然表示的int值相同，但是在堆中有两份，每次new都会在堆中开辟一片空间保存new的内容，故Integer b和Integer c分别在两片不同的内存空间存储，所以指向的内存地址不同。 而对于Integer b = 1;其反编译后为Integer b = Integer.valueOf(1);而valueOf()方法内部是调用了new。 JDK中Integer.valueOf()源码： 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 总结了解原理是弄清问题的关键，像这样的问题以后还多着呢。不懂的时候可以敲敲代码，然后反编译，看看虚拟机是怎么处理的，看看原理翻翻源码，问题也就迎刃而解了。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>包装类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何实现页面广告随时上下线、过期自动下线及到时自动上线]]></title>
    <url>%2Fpage%2F2k181v.html</url>
    <content type="text"><![CDATA[背景引入最近需要实现一个功能，关于页面广告自动配置的，如支付宝的支付完成页。这篇随笔是记录对这个需求从分析到实现以及优化的过程，以免以后忘记。 需求描述某些页面需要配置广告或活动宣传图，广告或活动需满足随时上下线、过期自动下线及到时自动上线。 如：现在时间2019-2-22 16:16:13，要在支付完成页面配置领奖活动，活动要在2019-3-10 00:00:00准时上线，在2019-3-30 23:59:59结束活动。 所以要的效果是，在活动上线前的任意时刻配置完活动后，页面到时间自动上线这个活动。也可能会是其他的多个活动或广告，每个页面广告的个数可变，不同上下线时间可不同，其他页面也需要实现这样的功能，页面与页面之间的活动不一定一样。 需求分析需求简单的几句话，那么我们来具体的分析一下。 提取关键词 广告或活动宣传图 随时上下线、过期自动下线及到时自动上线 每个页面广告的个数可变 不同广告上下线时间可不同 页面与页面之间的活动不一定一样数据库分析1、【广告或活动宣传图】 要为不同页面设置不同的广告，有的页面广告可能一样，也就是广告会复用，所有要有广告表。 2、【每个页面广告的个数可变】【不同广告上下线时间可不同】【页面与页面之间的活动不一定一样】 页面可配置多个广告，所有要有页面配置表，以及广告和页面的关系表，即页面广告表。 页面配置表主要配置页面的广告个数，实现【每个页面广告的个数可变】，页面广告表主要配置页面的每个广告上下线时间，实现【不同广告上下线时间可不同】 简单分析后得出如下表结构：广告表adv，页面配置表page_config，页面广告表page_adv 思考这些页面配置的广告在一段时间内是不会变的，如果页面请求次数较多，广告查询次数就会很频繁，对数据库造成不必要的压力。所以可以引入缓存，降低数据库请求次数，缓解数据库压力。这里使用的Redis。 何时入缓存？ 可以选择在服务启动时异步把已在上下线时间区间内的广告先加载至缓存，或选择在请求时取缓存，缓存内没有时再查库然后放缓存。缓存时间视情况而定。 这里选择的是，项目启动时异步把符合条件的页面广告配置信息存入Redis，那些还没到指定时间的先不放Redis，等到访问页面加载广告时，先查Redis，若无则按条件（&gt;=nowtime）查库，查到后存Redis。 在接口中拿到广告配置信息后，判断当前时间是否在配置的时间区间内，由于一个页面配置多个广告，不同广告时间也不同，所以要迭代，把符合的返回，有过期的就做标记，然后把整个页面的配置信息在Redis里删除。（或者不选择在启动时加载，就在用户请求时加入缓存，但是下面的第1步的方法在刷新加载时会用到，故不能删） 具体实现第1步、项目启动时先把页面广告配置信息存入Redisa、查询所有pageId 1SELECT pageId FROM page_config page_adv WHERE nowtime&lt;=endtime AND GROUP BY pageId 两个表内连接，得List&lt;pageId&gt;，得到的都是配置的有广告的并且广告还没过期的pageId。 b、查询pegeId对应的广告图片及跳转链接 1SELECT 字段名 FROM page_adv adv WHERE begintime&lt;=nowtime&lt;=endtime AND pageId=&#123;#pageId&#125; 然后把查到的配置信息List&lt;adv&gt;（为空时不做操作），以pageId为KEY放入缓存。 第2步、给前端写接口查询页面广告按标准的控制层，业务层，数据访问层写，第一步中的逻辑就是在业务层完成的。 控制层： 控制层接参pageId，调用业务层查询对应页面配置的广告信息，判空，直接返回状态码0，即无广告前端不展示。 不为空就根据业务逻辑处理数据（如img的URL加域名），然后返回状态码1，前端展示广告。这里控制层还可以加逻辑，迭代广告list，把当前时间在广告起始时间内的返回，不在的不返回，并且只要有一个广告过期，就把这个页面的广告list缓存清掉。这个逻辑是把过期的清掉。 业务层： 先取缓存，没有再查库判断不为空（本页面配置的有广告），放入缓存（pageId为KEY），然后返回。 数据访问层： SQL: 1SELECT 字段名 FROM page_config adv page_adv WHERE begintime&lt;=nowtime&lt;=endtime AND pageId=#&#123;pageId&#125; 三表联查，根据pageId查询当前页面配置的广告活动信息（已在广告活动时间内） 第3步、刷新加载为什么使用刷新加载？ 因为有这样的场景：给页面A配置了一个广告（当前时间在广告的起始时间内），那么这个页面的广告已经在缓存里了，假如此时A页面要新加一个广告，在后台配置后如果不做其他操作，这个广告不会显示（假设缓存时间较长，为一天），因为库更新了，缓存没有同步更新。 解决方案 使用Redis的发布订阅机制实现缓存的刷新加载，使新配置的广告及时能够显示。刷新加载的回调方法即第1步中的方法。 进一步优化想一想，目前的实现存在什么问题？ 存在的问题 假如有页面需要配置广告，但是还没有配（前端已经开发完上线，每次都会调接口查广告信息），那么数据库肯定查不到，缓存也没有。如果这个页面访问量很大，那么缓存没命中就查库，这样对库的压力就会很大，这就是缓存穿透，请求上来了很容易击垮数据库。那怎么办呢？ 解决方案 当页面没有配置广告时，在缓存存标志，查询时先看标志，在决定是否往下走。 具体方案 这时，上面的第1步就要改了。 1、首先改第1步的步骤a的SQL，把所有的pageId都查询出来。 使用左连接 1SELECT pageId FROM page_config LEFT JOIN page_adv ON ... GROUP BY pageId 或者干脆查page_config 1SELECT pageId FROM page_config 目的是把已在page_config表中配置，但关系表中page_adv未配置广告的pageId也查出来，这样才能给未配置广告的pageId在缓存里放标志 2、第1步的步骤b的SQL改为 1SELECT 字段名 FROM page_adv adv WHERE nowtime&lt;=endtime AND pageId=&#123;#pageId&#125; 然后把查到的配置信息放入缓存之前判断【为空时的不做操作】改为【为空时存入一个标志】假如这个标志KEY为pageId+”_EMPTY_FLAG”,value为”DB_IS_NULL” 为什么只判断小于结束时间 因为如果该页面配置的广告开始时间大于当前时间，那么这个是查不到的，会被处理为DATABASE_IS_NULL，如果在这个标志还没失效之前就到了配置的开始时间了，那么这个广告不会被展示。所有要让未到开始时间的也放入缓存，然后让控制层去判断在不在时间区间。 3、所以要在第2步也修改一下 在业务层里取缓存中的广告列表之前，先从缓存取pageId+”EMPTY_FLAG”的value判断为”DB_IS_NULL”直接返回空，这样就能解决缓存穿透的问题了。 继续修改第2步的业务层，查库的SQL同样要改： 1SELECT 字段名 FROM page_config adv page_adv WHERE nowtime&lt;=endtime AND pageId=#&#123;pageId&#125; 然后判断为空的话，同上面的黄字那样处理。 4、最后，第3步的刷新加载调的是第1步的方法，不用改。当然这个缓存穿透的优化方案只是其中一种。还可以这样： 1、控制层拦截：根据pageId查询page_adv表，查不到说明没配置，直接返回。 2、page_config 表增加字段，表示当前页面已经配置的广告个数，默认0，每配置一个该字段加1，把大于0的pageId缓存起来，调接口时前判断在不在缓存里。 总结：实现这个功能并不是太难，主要用到了Redis的缓存技术，Redis发布订阅机制，关键就是细节的把控，以及缓存穿透的处理。]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于java抽象类抽象方法]]></title>
    <url>%2Fpage%2Fa123d3.html</url>
    <content type="text"><![CDATA[你好！ 这篇文章将讲述java中的抽象类和抽象方法的知识点，这个是最简单的，也是最容易被遗忘的。温故而知新，可以为师矣。 抽象类抽象类里不一定有抽象方法。抽象类里的方法必须通过他的子类调用，因为抽象类不能被实例化。子类必须实现抽象类中的抽象方法（即使是空实现）。含有抽象方法的类必须是抽象类。 抽象类的写法： 123public abstract class Abstra&#123;​&#125; 抽象类需要被abstract 关键字修饰 抽象方法并不是抽象类里的方法都叫做抽象方法，抽象方法是抽象类里被abstract 关键字修饰的、只有方法头没有方法体的方法如下： 12345678public abstract class Abstra&#123; //抽象类里的非抽象方法 public void sd()&#123; System.out.println("sadds"); &#125; //抽象类里的抽象方法 public abstract void sum();&#125; 抽象类可以没有抽象方法 ##抽象类的方法怎么被调用 ## 因为抽象类不能被实例化，所以就得写个子类来继承他，再通过实例化子 类调用抽象类的方法 123456public abstract class Abstra&#123; //抽象类里的非抽象方法 public void sd()&#123; System.out.println("sadds"); &#125;&#125; 继承抽象类重写抽象方法 12345public class AbstraAbs extends Abstra&#123; public void sd() &#123; super.sd();//子类重写抽象方法，通过super调用父类方法 &#125;&#125; 获得子类实例调用子类方法 123456public class TestClass&#123; public static void main(String arg[])&#123; AbstraAbs abs = new AbstraAbs(); abs.sd(); &#125;&#125; 输出结果 1sadds 如果只是单纯的想调用抽象类的方法而不做任何改变，子类也可以这样写 123public class AbstraAbs extends Abstra&#123;​&#125; 就是什么都不用写，调用时调的还是抽象类里的那个方法。这是因为父子类的关系，不懂的可以看一下有关父子类的知识点。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>抽象类</tag>
        <tag>抽象方法</tag>
      </tags>
  </entry>
</search>
